import{evaluate as e,getConfig as t,log$1 as n,select_default as r}from"./mermaid-b5860b54.CzyV0eq4.js";import{Graph as i,isUndefined_default as a}from"./graphlib.B9UfIqo0.js";import{clone_default as o}from"./clone.A1bABoxq.js";import{createText as s}from"./createText-2e5e7dd3.DgWvnF3i.js";import{clear as c,clear$1 as l,createLabel$1 as u,getSubGraphTitleMargins as d,insertEdge as f,insertEdgeLabel as p,insertMarkers$1 as m,insertNode as h,intersectRect$1 as g,positionEdgeLabel as _,positionNode as v,setNodeElem as y,updateNodeBounds as b}from"./edges-e0da2a9e.DFFloXIu.js";import{layout as x,map_default as S}from"./dagre.v2GxACLv.js";function C(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:w(e),edges:T(e)};return a(e.graph())||(t.value=o(e.graph())),t}function w(e){return S(e.nodes(),function(t){var n=e.node(t),r=e.parent(t),i={v:t};return a(n)||(i.value=n),a(r)||(i.parent=r),i})}function T(e){return S(e.edges(),function(t){var n=e.edge(t),r={v:t.v,w:t.w};return a(t.name)||(r.name=t.name),a(n)||(r.value=n),r})}let E={},D={},O={};const k=()=>{D={},O={},E={}},A=(e,t)=>(n.trace(`In isDescendant`,t,` `,e,` = `,D[t].includes(e)),!!D[t].includes(e)),j=(e,t)=>(n.info(`Descendants of `,t,` is `,D[t]),n.info(`Edge is `,e),e.v===t||e.w===t?!1:D[t]?D[t].includes(e.v)||A(e.v,t)||A(e.w,t)||D[t].includes(e.w):(n.debug(`Tilt, `,t,`,not in descendants`),!1)),M=(e,t,r,i)=>{n.warn(`Copying children of `,e,`root`,i,`data`,t.node(e),i);let a=t.children(e)||[];e!==i&&a.push(e),n.warn(`Copying (nodes) clusterId`,e,`nodes`,a),a.forEach(a=>{if(t.children(a).length>0)M(a,t,r,i);else{let o=t.node(a);n.info(`cp `,a,` to `,i,` with parent `,e),r.setNode(a,o),i!==t.parent(a)&&(n.warn(`Setting parent`,a,t.parent(a)),r.setParent(a,t.parent(a))),e!==i&&a!==e?(n.debug(`Setting parent`,a,e),r.setParent(a,e)):(n.info(`In copy `,e,`root`,i,`data`,t.node(e),i),n.debug(`Not Setting parent for node=`,a,`cluster!==rootId`,e!==i,`node!==clusterId`,a!==e));let s=t.edges(a);n.debug(`Copying Edges`,s),s.forEach(a=>{n.info(`Edge`,a);let o=t.edge(a.v,a.w,a.name);n.info(`Edge data`,o,i);try{j(a,i)?(n.info(`Copying as `,a.v,a.w,o,a.name),r.setEdge(a.v,a.w,o,a.name),n.info(`newGraph edges `,r.edges(),r.edge(r.edges()[0]))):n.info(`Skipping copy of edge `,a.v,`-->`,a.w,` rootId: `,i,` clusterId:`,e)}catch(e){n.error(e)}})}n.debug(`Removing node`,a),t.removeNode(a)})},N=(e,t)=>{let n=t.children(e),r=[...n];for(let i of n)O[i]=e,r=[...r,...N(i,t)];return r},P=(e,t)=>{n.trace(`Searching`,e);let r=t.children(e);if(n.trace(`Searching children of id `,e,r),r.length<1)return n.trace(`This is a valid node`,e),e;for(let i of r){let r=P(i,t);if(r)return n.trace(`Found replacement for`,e,` => `,r),r}},F=e=>!E[e]||!E[e].externalConnections?e:E[e]?E[e].id:e,I=(e,t)=>{if(!e||t>10){n.debug(`Opting out, no graph `);return}else n.debug(`Opting in, graph `);e.nodes().forEach(function(t){let r=e.children(t);r.length>0&&(n.warn(`Cluster identified`,t,` Replacement id in edges: `,P(t,e)),D[t]=N(t,e),E[t]={id:P(t,e),clusterData:e.node(t)})}),e.nodes().forEach(function(t){let r=e.children(t),i=e.edges();r.length>0?(n.debug(`Cluster identified`,t,D),i.forEach(e=>{if(e.v!==t&&e.w!==t){let r=A(e.v,t),i=A(e.w,t);r^i&&(n.warn(`Edge: `,e,` leaves cluster `,t),n.warn(`Descendants of XXX `,t,`: `,D[t]),E[t].externalConnections=!0)}})):n.debug(`Not a cluster `,t,D)});for(let t of Object.keys(E)){let n=E[t].id,r=e.parent(n);r!==t&&E[r]&&!E[r].externalConnections&&(E[t].id=r)}e.edges().forEach(function(t){let r=e.edge(t);n.warn(`Edge `+t.v+` -> `+t.w+`: `+JSON.stringify(t)),n.warn(`Edge `+t.v+` -> `+t.w+`: `+JSON.stringify(e.edge(t)));let i=t.v,a=t.w;if(n.warn(`Fix XXX`,E,`ids:`,t.v,t.w,`Translating: `,E[t.v],` --- `,E[t.w]),E[t.v]&&E[t.w]&&E[t.v]===E[t.w]){n.warn(`Fixing and trixing link to self - removing XXX`,t.v,t.w,t.name),n.warn(`Fixing and trixing - removing XXX`,t.v,t.w,t.name),i=F(t.v),a=F(t.w),e.removeEdge(t.v,t.w,t.name);let o=t.w+`---`+t.v;e.setNode(o,{domId:o,id:o,labelStyle:``,labelText:r.label,padding:0,shape:`labelRect`,style:``});let s=structuredClone(r),c=structuredClone(r);s.label=``,s.arrowTypeEnd=`none`,c.label=``,s.fromCluster=t.v,c.toCluster=t.v,e.setEdge(i,o,s,t.name+`-cyclic-special`),e.setEdge(o,a,c,t.name+`-cyclic-special`)}else if(E[t.v]||E[t.w]){if(n.warn(`Fixing and trixing - removing XXX`,t.v,t.w,t.name),i=F(t.v),a=F(t.w),e.removeEdge(t.v,t.w,t.name),i!==t.v){let n=e.parent(i);E[n].externalConnections=!0,r.fromCluster=t.v}if(a!==t.w){let n=e.parent(a);E[n].externalConnections=!0,r.toCluster=t.w}n.warn(`Fix Replacing with XXX`,i,a,t.name),e.setEdge(i,a,r,t.name)}}),n.warn(`Adjusted Graph`,C(e)),L(e,0),n.trace(E)},L=(e,t)=>{if(n.warn(`extractor - `,t,C(e),e.children(`D`)),t>10){n.error(`Bailing out`);return}let r=e.nodes(),a=!1;for(let t of r){let n=e.children(t);a||=n.length>0}if(!a){n.debug(`Done, no node has children`,e.nodes());return}n.debug(`Nodes = `,r,t);for(let a of r)if(n.debug(`Extracting node`,a,E,E[a]&&!E[a].externalConnections,!e.parent(a),e.node(a),e.children(`D`),` Depth `,t),!E[a])n.debug(`Not a cluster`,a,t);else if(!E[a].externalConnections&&e.children(a)&&e.children(a).length>0){n.warn(`Cluster without external connections, without a parent and with children`,a,t);let r=e.graph(),o=r.rankdir===`TB`?`LR`:`TB`;E[a]&&E[a].clusterData&&E[a].clusterData.dir&&(o=E[a].clusterData.dir,n.warn(`Fixing dir`,E[a].clusterData.dir,o));let s=new i({multigraph:!0,compound:!0}).setGraph({rankdir:o,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});n.warn(`Old graph before copy`,C(e)),M(a,e,s,a),e.setNode(a,{clusterNode:!0,id:a,clusterData:E[a].clusterData,labelText:E[a].labelText,graph:s}),n.warn(`New graph after copy node: (`,a,`)`,C(s)),n.debug(`Old graph after copy`,C(e))}else n.warn(`Cluster ** `,a,` **not meeting the criteria !externalConnections:`,!E[a].externalConnections,` no parent: `,!e.parent(a),` children `,e.children(a)&&e.children(a).length>0,e.children(`D`),t),n.debug(E);r=e.nodes(),n.warn(`New list of nodes`,r);for(let i of r){let r=e.node(i);n.warn(` Now next level`,i,r),r.clusterNode&&L(r.graph,t+1)}},R=(e,t)=>{if(t.length===0)return[];let n=Object.assign(t);return t.forEach(t=>{let r=e.children(t),i=R(e,r);n=[...n,...i]}),n},z=e=>R(e,e.children()),B=(i,a)=>{n.info(`Creating subgraph rect for `,a.id,a);let o=t(),c=i.insert(`g`).attr(`class`,`cluster`+(a.class?` `+a.class:``)).attr(`id`,a.id),l=c.insert(`rect`,`:first-child`),f=e(o.flowchart.htmlLabels),p=c.insert(`g`).attr(`class`,`cluster-label`),m=a.labelType===`markdown`?s(p,a.labelText,{style:a.labelStyle,useHtmlLabels:f}):p.node().appendChild(u(a.labelText,a.labelStyle,void 0,!0)),h=m.getBBox();if(e(o.flowchart.htmlLabels)){let e=m.children[0],t=r(m);h=e.getBoundingClientRect(),t.attr(`width`,h.width),t.attr(`height`,h.height)}let _=0*a.padding,v=_/2,y=a.width<=h.width+_?h.width+_:a.width;a.width<=h.width+_?a.diff=(h.width-a.width)/2-a.padding/2:a.diff=-a.padding/2,n.trace(`Data `,a,JSON.stringify(a)),l.attr(`style`,a.style).attr(`rx`,a.rx).attr(`ry`,a.ry).attr(`x`,a.x-y/2).attr(`y`,a.y-a.height/2-v).attr(`width`,y).attr(`height`,a.height+_);let{subGraphTitleTopMargin:b}=d(o);f?p.attr(`transform`,`translate(${a.x-h.width/2}, ${a.y-a.height/2+b})`):p.attr(`transform`,`translate(${a.x}, ${a.y-a.height/2+b})`);let x=l.node().getBBox();return a.width=x.width,a.height=x.height,a.intersect=function(e){return g(a,e)},c},V=(e,t)=>{let n=e.insert(`g`).attr(`class`,`note-cluster`).attr(`id`,t.id),r=n.insert(`rect`,`:first-child`),i=0*t.padding,a=i/2;r.attr(`rx`,t.rx).attr(`ry`,t.ry).attr(`x`,t.x-t.width/2-a).attr(`y`,t.y-t.height/2-a).attr(`width`,t.width+i).attr(`height`,t.height+i).attr(`fill`,`none`);let o=r.node().getBBox();return t.width=o.width,t.height=o.height,t.intersect=function(e){return g(t,e)},n},H=(n,i)=>{let a=t(),o=n.insert(`g`).attr(`class`,i.classes).attr(`id`,i.id),s=o.insert(`rect`,`:first-child`),c=o.insert(`g`).attr(`class`,`cluster-label`),l=o.append(`rect`),f=c.node().appendChild(u(i.labelText,i.labelStyle,void 0,!0)),p=f.getBBox();if(e(a.flowchart.htmlLabels)){let e=f.children[0],t=r(f);p=e.getBoundingClientRect(),t.attr(`width`,p.width),t.attr(`height`,p.height)}p=f.getBBox();let m=0*i.padding,h=m/2,_=i.width<=p.width+i.padding?p.width+i.padding:i.width;i.width<=p.width+i.padding?i.diff=(p.width+i.padding*0-i.width)/2:i.diff=-i.padding/2,s.attr(`class`,`outer`).attr(`x`,i.x-_/2-h).attr(`y`,i.y-i.height/2-h).attr(`width`,_+m).attr(`height`,i.height+m),l.attr(`class`,`inner`).attr(`x`,i.x-_/2-h).attr(`y`,i.y-i.height/2-h+p.height-1).attr(`width`,_+m).attr(`height`,i.height+m-p.height-3);let{subGraphTitleTopMargin:v}=d(a);c.attr(`transform`,`translate(${i.x-p.width/2}, ${i.y-i.height/2-i.padding/3+(e(a.flowchart.htmlLabels)?5:3)+v})`);let y=s.node().getBBox();return i.height=y.height,i.intersect=function(e){return g(i,e)},o},U=(e,t)=>{let n=e.insert(`g`).attr(`class`,t.classes).attr(`id`,t.id),r=n.insert(`rect`,`:first-child`),i=0*t.padding,a=i/2;r.attr(`class`,`divider`).attr(`x`,t.x-t.width/2-a).attr(`y`,t.y-t.height/2).attr(`width`,t.width+i).attr(`height`,t.height+i);let o=r.node().getBBox();return t.width=o.width,t.height=o.height,t.diff=-t.padding/2,t.intersect=function(e){return g(t,e)},n},W={rect:B,roundedWithTitle:H,noteGroup:V,divider:U};let G={};const K=(e,t)=>{n.trace(`Inserting cluster`);let r=t.shape||`rect`;G[t.id]=W[r](e,t)},q=()=>{G={}},J=async(e,t,r,i,a,o)=>{n.info(`Graph in recursive render: XXX`,C(t),a);let s=t.graph().rankdir;n.trace(`Dir in recursive render - dir:`,s);let c=e.insert(`g`).attr(`class`,`root`);t.nodes()?n.info(`Recursive render XXX`,t.nodes()):n.info(`No nodes found for`,t),t.edges().length>0&&n.trace(`Recursive edges`,t.edge(t.edges()[0]));let l=c.insert(`g`).attr(`class`,`clusters`),u=c.insert(`g`).attr(`class`,`edgePaths`),m=c.insert(`g`).attr(`class`,`edgeLabels`),g=c.insert(`g`).attr(`class`,`nodes`);await Promise.all(t.nodes().map(async function(e){let c=t.node(e);if(a!==void 0){let r=JSON.parse(JSON.stringify(a.clusterData));n.info(`Setting data for cluster XXX (`,e,`) `,r,a),t.setNode(a.id,r),t.parent(e)||(n.trace(`Setting parent`,e,a.id),t.setParent(e,a.id,r))}if(n.info(`(Insert) Node XXX`+e+`: `+JSON.stringify(t.node(e))),c&&c.clusterNode){n.info(`Cluster identified`,e,c.width,t.node(e));let a=await J(g,c.graph,r,i,t.node(e),o),s=a.elem;b(c,s),c.diff=a.diff||0,n.info(`Node bounds (abc123)`,e,c,c.width,c.x,c.y),y(s,c),n.warn(`Recursive render complete `,s,c)}else t.children(e).length>0?(n.info(`Cluster - the non recursive path XXX`,e,c.id,c,t),n.info(P(c.id,t)),E[c.id]={id:P(c.id,t),node:c}):(n.info(`Node - the non recursive path`,e,c.id,c),await h(g,t.node(e),s))})),t.edges().forEach(function(e){let r=t.edge(e.v,e.w,e.name);n.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(e)),n.info(`Edge `+e.v+` -> `+e.w+`: `,e,` `,JSON.stringify(t.edge(e))),n.info(`Fix`,E,`ids:`,e.v,e.w,`Translating: `,E[e.v],E[e.w]),p(m,r)}),t.edges().forEach(function(e){n.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(e))}),n.info(`#############################################`),n.info(`###                Layout                 ###`),n.info(`#############################################`),n.info(t),x(t),n.info(`Graph after layout:`,C(t));let S=0,{subGraphTitleTotalMargin:w}=d(o);return z(t).forEach(function(e){let r=t.node(e);n.info(`Position `+e+`: `+JSON.stringify(t.node(e))),n.info(`Position `+e+`: (`+r.x,`,`+r.y,`) width: `,r.width,` height: `,r.height),r&&r.clusterNode?(r.y+=w,v(r)):t.children(e).length>0?(r.height+=w,K(l,r),E[r.id].node=r):(r.y+=w/2,v(r))}),t.edges().forEach(function(e){let a=t.edge(e);n.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(a),a),a.points.forEach(e=>e.y+=w/2);let o=f(u,e,a,E,r,t,i);_(a,o)}),t.nodes().forEach(function(e){let r=t.node(e);n.info(e,r.type,r.diff),r.type===`group`&&(S=r.diff)}),{elem:c,diff:S}},Y=async(e,r,i,a,o)=>{m(e,i,a,o),l(),c(),q(),k(),n.warn(`Graph at first:`,JSON.stringify(C(r))),I(r),n.warn(`Graph after:`,JSON.stringify(C(r)));let s=t();await J(e,r,a,o,void 0,s)};export{Y as render};